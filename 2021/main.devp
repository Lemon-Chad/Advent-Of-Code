#func main;

import iofile as io;
const { * } => import std;

class AOCLogger {
    indentation: num => 0;

    mthd log<msg> {
        if (indentation == 0) {
            println(msg);
        } else {
            for (_ -> 0:indentation) {
                print("  ");
            }
            println("- " + msg);
        }
    }

    mthd indent {
        indentation++;
    }

    mthd outdent {
        indentation--;
        println("");
    }
}
const Logger => AOCLogger();

class Helper {

    mthd stc sumsLessThan<lis #list> = num {
        let sum => 0;
        for (i -> 0 : --(lis.size())) {
            if (lis[i] < lis[++i])
                sum++;
        }
        return sum;
    }

    mthd stc slidingThrees<lis #list> = list -> for (i -> 0 : (lis.size()) - 2) => lis[i] + lis[i + 1] + lis[i + 2];

}

<> Advent of Code 2021 - Day 1
class DayOne {
    stc numbers: list => for (x <- io::readFile("inputs/1.txt").split("\n")) => parseNum(x);


    mthd stc partOne = num {
        return Helper::sumsLessThan(DayOne::numbers);
    }

    mthd stc partTwo = num {
        return Helper::sumsLessThan(Helper::slidingThrees(DayOne::numbers));
    }

    mthd stc main {
        Logger::log("Day One:");
        Logger::indent();
        Logger::log("Part One: " + DayOne::partOne());
        Logger::log("Part Two: " + DayOne::partTwo());
        Logger::outdent();
    }
}

<> Advent of Code 2021 - Day 2
class DayTwo {
    stc movements: list => 
        for (x <- io::readFile("inputs/2.txt").split("\n")) => 
            Tuple(
                (var y => x.split(" "))[0], 
                parseNum(y[1])
            );

    mthd stc partOne = num {
        let x => 0;
        let depth => 0;
        
        for (movement <- DayTwo::movements) {
            let offs => *movement[1];
            let dir => *movement[0];

            match (dir) {
                "forward" -> x += offs;
                "down" -> depth += offs;
                "up" -> depth -= offs;
                default -> throw "Invalid direction";
            };
        }

        return x * depth;
    }

    mthd stc partTwo {
        let x => 0;
        let depth => 0;
        let aim => 0;

        for (movement <- DayTwo::movements) {
            let offs => *movement[1];
            let dir => *movement[0];

            match (dir) {
                "forward" -> scope {
                    x += offs;
                    depth += offs * aim;
                }
                "down" -> aim += offs;
                "up" -> aim -= offs;
            };
        }

        return x * depth;
    }

    mthd stc main {
        Logger::log("Day Two:");
        Logger::indent();
        Logger::log("Part One: " + DayTwo::partOne());
        Logger::log("Part Two: " + DayTwo::partTwo());
        Logger::outdent();
    }

}

fn main<args #list> {
    DayOne::main();
    DayTwo::main();
}
